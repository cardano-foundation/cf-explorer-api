// var stt = "200";
// stt = pm.variables.get("stt");
var jsonData = pm.response.json();
var metadataLst = pm.response.json().metadata;

var metadataCIP20 = metadataLst ? metadataLst.shift() : undefined;
var metadataCIP83 = metadataLst ? metadataLst.shift() : undefined;
var metadataBolnisi = metadataLst ? metadataLst.shift() : undefined;
var wineryData = metadataBolnisi?.wineryData;

pm.test("Status code is 200", function () {
    pm.response.to.have.status(200);
});

pm.test("Response time is less than 5000ms", function () {
    pm.expect(pm.response.responseTime).to.be.below(5000);
});

pm.test("Check maxEpochSlot value", function () {
    pm.expect(jsonData.tx.maxEpochSlot).to.eql(432000);
});

//Compare data type
pm.test("Check data type of the response", () => {
    let moment = require('moment');
    pm.expect(jsonData.tx.hash).to.be.a("string");
    pm.expect(jsonData.tx.time).to.include(moment(jsonData.tx.time).format('YYYY/MM/DD HH:mm:ss'));
    pm.expect(jsonData.tx.blockNo).to.be.a("number");
    pm.expect(jsonData.tx.blockHash).to.be.a("string");
    pm.expect(jsonData.tx.epochSlot).to.be.a("number");
    pm.expect(jsonData.tx.maxEpochSlot).to.be.a("number");
    pm.expect(jsonData.tx.epochNo).to.be.a("number");
    pm.expect(jsonData.tx.status).to.be.a("string");
    pm.expect(jsonData.tx.confirmation).to.be.a("number");
    pm.expect(jsonData.tx.fee).to.be.a("number");
    pm.expect(jsonData.tx.totalOutput).to.be.a("number");
});

const checkToken = (data) => {
    if (data.policy) {
        pm.expect(data.policy).to.be.a("string");
    }

    if (data.assetName) {
        pm.expect(data.assetName).to.be.a("string");
    }
    // if (data.assetQuantity) {
    //     pm.expect(data.assetQuantity).to.be.a("number");
    // }
    if (data.assetId) {
        pm.expect(data.assetId).to.be.a("string");
    }
    // if (data.addressId) {
    //     pm.expect(data.addressId).to.be.a("number");
    // }
    if (data.address) {
        pm.expect(data.address).to.be.a("string");
    }
    if (data.addressType) {
        pm.expect(data.addressType).to.contain.oneOf(["STAKE_ADDRESS", "PAYMENT_ADDRESS"])
    }
    if (data.name) {
        pm.expect(data.name).to.be.a("string");
    }
    if (data.displayName) {
        pm.expect(data.displayName).to.be.a("string");
    }
    if (data.fingerprint) {
        pm.expect(data.fingerprint).to.be.a("string");
    }
    // if (data.quantity) {
    //     pm.expect(data.quantity).to.be.a("number");
    // }
    if (data.metadata) {
        if (data.metadata.url) {
            pm.expect(data.metadata.url).to.be.a("string");
        }
        if (data.metadata.logo) {
            pm.expect(data.metadata.logo).to.be.a("string");
        }
        if (data.metadata.ticker) {
            pm.expect(data.metadata.ticker).to.be.a("string", "data.metadata.ticker");
        }
        if (data.metadata.decimals) {
            pm.expect(data.metadata.decimals).to.be.a("number");
        }
        if (data.metadata.description) {
            pm.expect(data.metadata.description).to.be.a("string");
        }
    }
}

const checkUTXO = (data) => {
    (data || []).map(d => {
        pm.expect(d.address).to.be.a("string")
        if (d.txHash) {
            pm.expect(d.txHash).to.be.a("string")
        }
        if (d.assetId) {
            pm.expect(d.assetId).to.be.a("string")
        }
        // if(d.value){
        //     pm.expect(d.value).to.be.a("number")
        // }
        pm.expect(d.index).to.be.a("string")

        if (d.tokens && d.tokens.length > 0) {
            d.tokens.map(t => checkToken(t))
        }
        if (d.stakeAddress && d.stakeAddress.length > 0) {
            pm.expect(d.stakeAddress).to.be.a("string")
        }
    })
}

// UTXO
pm.test("check UTXOs data", () => {
    const UTXOsData = jsonData.utxOs
    if (UTXOsData.inputs && UTXOsData.inputs.length > 0) {
        checkUTXO(UTXOsData.inputs)
    }
    if (UTXOsData.outputs && UTXOsData.outputs.length > 0) {
        checkUTXO(UTXOsData.outputs)
    }
})

// sumamry 
pm.test("check type sumamry", () => {
    const summaryData = jsonData.summary.stakeAddress[0]
    if (summaryData.address) {
        pm.expect(summaryData.address).to.be.a("string");
    }
    if (summaryData.value) {
        pm.expect(summaryData.value).to.be.a("number");
    }
    if (summaryData.tokens && summaryData.tokens.length > 0) {
        summaryData.tokens.map(t => checkToken(t))
    }
    if (summaryData.stakeAddress) {
        pm.expect(summaryData.stakeAddress).to.be.a("string")
    }
})

//Contracts
pm.test("check type of contracts", () => {
    if (jsonData.contracts && jsonData.contracts.length > 0) {
        const contractData = jsonData.contracts[0]
        const referenceInputsData = contractData.referenceInputs[0]
        pm.expect(contractData.scriptHash).to.be.a("string");
        pm.expect(contractData.purpose).to.contain.oneOf(["SPEND", "MINT", "CERT", "REWARD"])
        pm.expect(contractData.redeemerBytes).to.be.a("string");
        pm.expect(contractData.redeemerMem).to.be.a("number");
        pm.expect(contractData.redeemerSteps).to.be.a("number");
        pm.expect(contractData.datumHashIn).to.be.a("string");
        pm.expect(contractData.datumBytesIn).to.be.a("string");
        pm.expect(contractData.scriptBytes).to.be.a("string");
        pm.expect(contractData.scriptBytes).to.be.a("string");
        if (contractData.datumBytesOut) {
            pm.expect(contractData.datumBytesOut).to.be.a("string");
        }
        if (contractData.mintingTokens) {
            contractData.mintingTokens.map(c => checkToken(c))
        }
        if (contractData.burningTokens) {
            contractData.burningTokens.map(c => checkToken(c))
        }
        pm.expect(contractData.utxoIndex).to.be.a("number");
        pm.expect(contractData.utxoHash).to.be.a("string");
        if (contractData.redeemerCertType) {
            pm.expect(contractData.redeemerCertType).to.contain.oneOf(["DELEGATION", "STAKE_DEREGISTRATION"])
        }
        if (referenceInputsData && referenceInputsData.length > 0) {
            pm.expect(referenceInputsData.address).to.be.a("string");
            pm.expect(referenceInputsData.index).to.be.a("number");
            pm.expect(referenceInputsData.txHash).to.be.a("string");
            if (referenceInputsData.tokens) {
                referenceInputsData.tokens.map(e => checkToken(e))
            }
            pm.expect(referenceInputsData.datumHash).to.be.a("string");
            pm.expect(referenceInputsData.datum).to.be.a("string");
            pm.expect(referenceInputsData.scriptHash).to.be.a("string");
            pm.expect(referenceInputsData.scriptType).to.be.a("string");
            pm.expect(referenceInputsData.script).to.be.a("string");
        }
        if (contractData.executionInputs && contractData.executionInputs.length > 0) {
            pm.expect(contractData.executionInputs[0]).to.be.a("string");
        }
        if (contractData.executionOutputs && contractData.executionOutputs.length > 0) {
            pm.expect(contractData.executionOutputs[0]).to.be.a("string");
        }
    }
})

// collaterals
pm.test("check collaterals data", () => {
    if (jsonData.collaterals) {
        const CollateralsData = jsonData.collaterals
        if (CollateralsData.collateralInputResponses) {
            checkUTXO(CollateralsData.collateralInputResponses)
        }
        if (CollateralsData.collateralOutputResponses) {
            checkUTXO(CollateralsData.collateralOutputResponses)
        }
    }
})

//withdrawals
pm.test("Check type of withdrawals", () => {
    console.log(jsonData.withdrawals)
    if (jsonData.withdrawals && jsonData.withdrawals.length > 0) {
        const withdrawalsData = jsonData.withdrawals[0]
        pm.expect(withdrawalsData.stakeAddressFrom).to.be.a("string");
        if (withdrawalsData.addressTo.length > 0) {
            pm.expect(withdrawalsData.addressTo[0]).to.be.a("string")
        }
        pm.expect(withdrawalsData.amount).to.be.a("number");
    }
})

//delegations
pm.test("Check type of delegations", () => {
    console.log(jsonData.delegations)
    if (jsonData.delegations && jsonData.delegations.length > 0) {
        const delegationsData = jsonData.delegations[0]
        pm.expect(delegationsData.address).to.be.a("string");
        pm.expect(delegationsData.poolId).to.be.a("string");
    }
})

//mints
pm.test("Check type of mints", () => {
    if (jsonData.mints && jsonData.mints.length > 0) {
        jsonData.mints.map(m =>
            checkToken(m)
        )
    }
})

// stakeCertificates
pm.test("Check type of stakeCertificates", () => {
    if (jsonData.stakeCertificates && jsonData.stakeCertificates.length > 0) {
        const stakeCertificatesData = jsonData.stakeCertificates[0]
        pm.expect(stakeCertificatesData.stakeAddress).to.be.a("string");
        pm.expect(stakeCertificatesData.type).to.contain.oneOf(["STAKE_REGISTRATION", "STAKE_DEREGISTRATION", "POOL_REGISTRATIO", "POOL_DEREGISTRATION"]);
    }
})

//poolCertificates
pm.test("Check type of poolCertificates", () => {
    if (jsonData.poolCertificates && jsonData.poolCertificates.length > 0) {
        const poolCertificatesData = jsonData.poolCertificates[0]
        pm.expect(poolCertificatesData.poolId).to.be.a("string");
        pm.expect(poolCertificatesData.epoch).to.be.a("number")
        pm.expect(poolCertificatesData.vrfKey).to.be.a("string")
        pm.expect(poolCertificatesData.rewardAccount).to.be.a("string")
        pm.expect(poolCertificatesData.poolOwners[0]).to.be.a("string")
        pm.expect(poolCertificatesData.metadataHash).to.be.a("string")
        pm.expect(poolCertificatesData.metadataUrl).to.be.a("string")
        pm.expect(poolCertificatesData.margin).to.be.a("number")
        pm.expect(poolCertificatesData.cost).to.be.a("number")
        pm.expect(poolCertificatesData.pledge).to.be.a("number")
        pm.expect(poolCertificatesData.type).to.contain.oneOf(["STAKE_REGISTRATION", "STAKE_DEREGISTRATION", "POOL_REGISTRATION", "POOL_DEREGISTRATION"])
    }
})

// instantaneousRewards
pm.test("Check type of instantaneousRewards", () => {
    if (jsonData.instantaneousRewards && jsonData.instantaneousRewards.length > 0) {
        const instantaneousRewardsData = jsonData.instantaneousRewards[0]
        pm.expect(instantaneousRewardsData.stakeAddress).to.be.a("string");
        pm.expect(instantaneousRewardsData.amount).to.be.a("string")
    }
})

// signersInformation
pm.test("Check type of signersInformation", () => {
    if (jsonData.signersInformation && jsonData.signersInformation.length > 0) {
        const signersInformationData = jsonData.signersInformation[0]
        pm.expect(signersInformationData.publicKey).to.be.a("string");
        pm.expect(signersInformationData.publicKey).to.be.a("string")
    }
})

//CIP20
pm.test("Check metadata CIP 20", function () {
    if (metadataCIP20?.valid) {
        pm.expect(metadataCIP20?.valid).to.be.a("boolean", "metadataCIP20.valid")
    }
    if (metadataCIP20?.valid?.requireProperties && metadataCIP20?.valid?.requireProperties.length > 0) {
        metadataCIP20.valid.requireProperties.map(require => {
            pm.expect(require.index).to.be.a("string", "require.index")
            pm.expect(require.valid).to.be.a("boolean", "require.valid")
            pm.expect(require.value).to.be.a("string", "require.value")
            pm.expect(require.property).to.be.a("string", "require.property")
            pm.expect(require.format).to.be.a("string", "require.format")
        })
    }
});

//CIP83
pm.test("Check metadata CIP 83", function () {
    if (metadataCIP83?.valid) {
        pm.expect(metadataCIP83?.valid).to.be.a("boolean", "metadataCIP83.valid")
    }
    if (metadataCIP83?.valid?.requireProperties && metadataCIP83?.valid?.requireProperties.length > 0) {
        metadataCIP83?.valid?.requireProperties.map(require => {
            pm.expect(require.index).to.be.a("string", "require.index")
            pm.expect(require.valid).to.be.a("boolean", "require.valid")
            pm.expect(require.value).to.be.a("string", "require.value")
            pm.expect(require.property).to.be.a("string", "require.property")
            pm.expect(require.format).to.be.a("string", "require.format")
        })
    }
});

//Label 1904
pm.test("Check validate Bolnisi Metadata - SCM", function () {
    if (metadataBolnisi?.cid) {
        pm.expect(metadataBolnisi.cid).to.be.a("string", "cid")
    }
    if (wineryData && wineryData.length > 0) {
        pm.expect(wineryData).to.be.an("array", "metadataBolnisi.wineryData")
        pm.expect(wineryData[0].pkeyVerified).to.be.a("boolean", "pkeyVerified")
        wineryData.map((winery) => {
            pm.expect(winery.wineryId).to.be.a("string", "wineryId");
            if (wineryData.lots && wineryData.lots.length > 0) {
                let moment = require('moment');
                pm.expect(wineryData.lots).to.be.an("array", "lots");
                pm.expect(wineryData.lots[0].signature).to.be.a("string", "signature");
                pm.expect(wineryData.lots[0].signatureVerified).to.be.a("boolean", "signatureVerified")
                pm.expect(wineryData.lots[0].offChainData).to.be.an("object", "offChainData");
                pm.expect(wineryData.lots[0].offChainData.bottling_location).to.be.a("string", "bottling_location");
                pm.expect(wineryData.lots[0].offChainData.country_of_origin).to.be.a("string", "country_of_origin");
                pm.expect(wineryData.lots[0].offChainData.fermentation_duration).to.be.a("string", "fermentation_duration");
                pm.expect(wineryData.lots[0].offChainData.fermentation_vessel).to.be.a("string", "fermentation_vessel");
                pm.expect(wineryData.harvest_date).to.include(moment(wineryData.harvest_date).format('YYYY/MM/DD HH:mm:ss'));
                pm.expect(wineryData.lots[0].offChainData.harvest_location).to.be.a("string", "harvest_location");
                pm.expect(wineryData.lots[0].offChainData.lot_number).to.be.a("string", "lot_number");
                pm.expect(wineryData.lots[0].offChainData.number_of_bottles).to.be.a("number", "number_of_bottles");
                pm.expect(wineryData.lots[0].offChainData.origin).to.be.a("string", "origin");
                pm.expect(wineryData.pressing_date).to.include(moment(wineryData.pressing_date).format('YYYY/MM/DD HH:mm:ss'));
                pm.expect(wineryData.lots[0].offChainData.processing_location).to.be.a("string", "processing_location");
                pm.expect(wineryData.lots[0].offChainData.produced_by).to.be.a("string", "produced_by");
                pm.expect(wineryData.lots[0].offChainData.producer_address).to.be.a("string", "producer_address");
                pm.expect(wineryData.lots[0].offChainData.producer_latitude).to.be.a("number", "producer_latitude");
                pm.expect(wineryData.lots[0].offChainData.producer_longitude).to.be.a("number", "producer_longitude");
                pm.expect(wineryData.lots[0].offChainData.storage_vessel).to.be.a("string", "storage_vessel");
                pm.expect(wineryData.lots[0].offChainData.varietal_name).to.be.a("string", "varietal_name");
                pm.expect(wineryData.lots[0].offChainData.varietal_name).to.be.a("number", "varietal_name");
                pm.expect(wineryData.lots[0].offChainData.wine_color).to.be.a("string", "wine_color");
                pm.expect(wineryData.lots[0].offChainData.wine_name).to.be.a("string", "wine_name");
                pm.expect(wineryData.lots[0].offChainData.wine_type).to.be.a("string", "wine_type");
            }
        });
    }
});

// Scenario Compare api: Filter transaction with api: Get transaction detail by hash
pm.test("Check blockNo value", function () {
    pm.expect(jsonData.tx.blockNo).to.eql(pm.environment.get("tx_blockNo"));
});

pm.test("Check blockHash value", function () {
    pm.expect(jsonData.tx.blockHash).to.include(pm.environment.get("tx_blockHash"));
});

pm.test("Check epochNo value", function () {
    pm.expect(jsonData.tx.epochNo).to.eql(pm.environment.get("tx_epochNo"));
});

pm.test("Check epochSlot value", function () {
    pm.expect(jsonData.tx.epochSlot).to.eql(pm.environment.get("tx_epochSlotNo"));
});

pm.test("Check fee value", function () {
    pm.expect(jsonData.tx.fee).to.eql(pm.environment.get("tx_fee"));
});

pm.test("Check totalOutput value", function () {
    pm.expect((jsonData.tx.totalOutput / 10 ** 6).toFixed(2)).to.eql((pm.environment.get("tx_amount") / 10 ** 6).toFixed(2));
});

